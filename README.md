# Elixir Thrift

[![Hex Version](https://img.shields.io/hexpm/v/thrift.svg)](https://hex.pm/packages/thrift)
[![Hex Docs](https://img.shields.io/badge/docs-hexpm-blue.svg)](https://hexdocs.pm/thrift/)
[![Build Status](https://travis-ci.org/pinterest/elixir-thrift.svg?branch=master)](https://travis-ci.org/pinterest/elixir-thrift)
[![Coverage Status](https://coveralls.io/repos/pinterest/elixir-thrift/badge.svg?branch=master)](https://coveralls.io/github/pinterest/elixir-thrift?branch=master)

This package contains an implementation of [Thrift](https://thrift.apache.org/) for Elixir.
It includes a Thrift IDL parser, a code generator, a binary framed client and a binary framed server.

The serialization and deserialization code that is generated by this project is highly
optimized and is between **10 and 25 times faster**<sub>[why?](#why-is-it-faster-than-the-apache-implementation)</sub> than the code generated by the
Apache Erlang implementation.

## Project Status

[Version 2.0](https://github.com/pinterest/elixir-thrift/milestone/1) is under
actively development and should be released soon. It is a complete rewrite
that drops the Apache Thrift dependency and implements everything in pure
Elixir.

## Getting Started

Until version 2.0 is released, you'll need to track the master branch
directly:

```elixir
{:thrift, github: "pinterest/elixir-thrift"}
```

This package includes a Mix compiler task that automates Thrift code
generation. Prepend `:thrift` to your project's `:compilers` list and add a
new top-level `:thrift` configuration key. The only necessary compiler option
is `:files`, which defines the list of Thrift files that should be compiled.

```elixir
# mix.exs
defmodule MyProject.Mixfile do
  # ...
  def project do
    [
      # ...
      thrift: [
        files: Path.wildcard("thrift/**/*.thrift")
      ]
    ]
  end
end
```

## Using the Client
The client includes a static module that does most of the work, and a generated
interface module that performs some conversions and makes calling remote
functions easier. You will not directly interface with the static module,
but it is the one that's started when `start_link` is called.

The static client module uses [James Fish](http://github.com/fishcakez)'s
excellent [connection](http://github.com/fishcakez/connection) behaviour.

For each function defined in the service, the generated module has
four functions.

Function name  | Description
---------------|----------
`get_user_by_id/3` | Makes a request to the remote `get_user_by_id` RPC. You can optionally pass `gen_tcp` and `GenServer` options (such as a timeout) to the client as the final `rpc_opts` argument. Returns `{:ok, response}` or `{:error, reason}` tuples.
`get_user_by_id!/3`  | Same as above, but raises an exception if something goes wrong. The type of exception can be one of the exceptions defined in the service or `Thrift.TApplicationException`.

To use the client, simply call `start_link`, supplying the host and port.

```elixir
iex> alias Thrift.Test.UserService.Binary.Framed.Client
iex> {:ok, client} = Client.start_link("localhost", 2345, [])
iex> {:ok, user} = Client.get_user_by_id(client, 22451)
{:ok, %Thrift.Test.User{id: 22451, username: "stinky", first_name: "Stinky", last_name: "Stinkman"}}
```

## Using The Server
Creating a thrift server is slightly more involved than creating the client, because
you need to create a module to handle the work. Fortunately, Elixir Thrift
creates a [Behaviour](http://elixir-lang.org/docs/stable/elixir/behaviours.html#content),
complete with correct success typing, for this module. To implement this behaviour,
use the `@behaviour` module attribute. The compiler will now inform you about
any missed functions.

Here is an implementation for the server defined above:

```elixir
defmodule UserServiceHandler do
  @behaviour Thrift.Test.UserService.Handler

  def ping, do: true

  def get_user_by_id(user_id) do
    case Backend.find_user_by_id(user_id) do
      {:ok, user} ->
        user
      {:error, _} ->
        raise Thrift.Test.UserNotFound.exception message: "could not find user with id #{user_id}"
    end
  end

  def delete_user(user_id) do
    Backend.delete_user(user_id) == :ok
  end
end
```

To start a server with UserServiceHandler as the callback module:

```elixir
{:ok, server_pid} = Thrift.Test.UserService.Binary.Framed.Server.start_link(UserServiceHandler, 2345, [])
```

...and your server is up and running. RPC calls to the server are delegated to UserServiceHandler.

The server defines a Supervisor, which can be added to your application's supervision tree. When adding the server to your applications supervision tree, use the `supervisor` function rather than the `worker` function.

## Using the binary protocol directly

Each thrift struct, union and exception also has a `BinaryProtocol` module generated for
it. This module lets you serialize and deserialize its own type easily.

For example:

```elixir
iex(1)> serialized = %User{username: "stinky" id: 1234, first_name: "Stinky", last_name: "Stinkman"}
|> User.BinaryProtocol.serialize
|> IO.iodata_to_binary
iex(2)> User.BinaryProtocol.deserialize(serialized)
{%User{username: "stinky" id: 1234, first_name: "Stinky", last_name: "Stinkman"}, ""}
```

The return value of the `serialize` function is an [iodata]. You can pass it through `IO.iodata_to_binary` to convert it to a binary. You also can write the iodata directly to a file or socket without converting it.

## Other Features
### Thrift IDL Parsing

This package also contains support for parsing [Thrift IDL][idl]
files. It is built on a low-level Erlang lexer and parser:

```elixir
{:ok, tokens, _} = :thrift_lexer.string('enum Colors { RED, GREEN, BLUE }')
{:ok,
 [{:enum, 1}, {:ident, 1, 'Colors'}, {:symbol, 1, '{'}, {:ident, 1, 'RED'},
  {:symbol, 1, ','}, {:ident, 1, 'GREEN'}, {:symbol, 1, ','},
  {:ident, 1, 'BLUE'}, {:symbol, 1, '}'}], 1}

{:ok, schema} = :thrift_parser.parse(tokens)
{:ok,
 %Thrift.AST.Schema{constants: %{},
  enums: %{Colors: %Thrift.AST.TEnum{name: :Colors,
     values: [RED: 1, GREEN: 2, BLUE: 3]}}, exceptions: %{}, includes: [],
  namespaces: %{}, services: %{}, structs: %{}, thrift_namespace: nil,
  typedefs: %{}, unions: %{}}}
```

But also provides a high-level Elixir parsing interface:

```elixir
Thrift.Parser.parse("enum Colors { RED, GREEN, BLUE }")
%Thrift.AST.Schema{constants: %{},
 enums: %{Colors: %Thrift.AST.TEnum{name: :Colors,
    values: [RED: 1, GREEN: 2, BLUE: 3]}}, exceptions: %{}, includes: [],
 namespaces: %{}, services: %{}, structs: %{}, thrift_namespace: nil,
 typedefs: %{}, unions: %{}}
```

You can use these features to support additional languages, protocols, and servers.

[idl]: https://thrift.apache.org/docs/idl
[iodata]: http://elixir-lang.org/getting-started/io-and-the-file-system.html#iodata-and-chardata

## Quick and dirty FAQ

### Why is it faster than the Apache implementation?
The Apache Thrift implementation uses C++ to write Erlang modules that describe Thrift data
structures, then uses that description to turn your Thrift data into bytes. It consults this
description every time Thrift data is serialized/deserialized. This on-the-fly conversion
costs CPU time.

Additionally, the separation of concerns in Thrift prevent the Erlang VM from doing the best
job that it can do during serialization.

On the other hand, this implementation uses Elixir to write Elixir code that's specific
 to _your_ thrift data. This serialization logic is then compiled, and that compiled code
is what converts your data to/from bytes. We've spent a lot of time making sure
that the generated serialization code takes advantage of several of the optimizations
that the Erlang VM provides.

### What tradeoffs have you made to get this performance?

Thrift has the following concepts:

   1. **Protocols** Define a conversion of data into bytes.
   2. **Transports** Define how bytes move; across a network or in and out of a file.
   3. **Processors** Encapsulate reading from streams and doing something with the data. Processors are generated by the Thrift compiler.

In Apache Thrift, Protocols and Transports can be mixed and matched. However, our implementation
does the mixing and matching for you and generates a combination of (Protocol + Transport +
Processor). This means that if you need to create a new Protocol or Transport, you need to
integrate it into this project.

Presently, we implement:

* Binary Protocol, Framed Client
* Binary Protocol, Framed Server

We are more than willing to take PRs to add more. We intend to also add TMux and Finagle servers
in the future.
